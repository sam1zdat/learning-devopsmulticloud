# üöÄ TP Complet: Pipeline Jenkins pour Docker Hub

## üìù **Objectif du TP**
Cr√©er un pipeline Jenkins complet qui build et d√©ploie une application Flask conteneuris√©e sur Docker Hub.

---
## üéØ Objectif de l'exercice

Cr√©er un pipeline Jenkins qui:
1. R√©cup√®re le code depuis GitHub
2. Build une image Docker
3. Push l'image vers Docker Hub
4. D√©ploie l'application

## üìã Pr√©requis

- Jenkins install√© avec les plugins Docker et Pipeline
- Docker install√© sur la machine Jenkins
- Compte Docker Hub
- Repository GitHub avec votre code

---

## üèóÔ∏è **Partie 1: Configuration de l'Environnement**


### **√âtape 1.1: Pr√©paration du Syst√®me**

```bash
#!/bin/bash
echo "üîß PR√âPARATION DU SYST√àME"

# Mettre √† jour le syst√®me
sudo apt-get update
sudo apt-get upgrade -y

# Installer les outils essentiels
sudo apt-get install -y \
    curl \
    wget \
    gnupg \
    software-properties-common \
    apt-transport-https \
    ca-certificates
```

### **√âtape 1.2: Installation de Java 17 (LTS Recommand√©e)**

```bash
#!/bin/bash
echo "‚òï INSTALLATION DE JAVA 17 LTS"

# Installer Java 17 JDK
sudo apt-get install -y openjdk-17-jdk

# Configurer JAVA_HOME
export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64
echo "export JAVA_HOME=$JAVA_HOME" | sudo tee -a /etc/profile.d/java.sh
echo "export PATH=\$JAVA_HOME/bin:\$PATH" | sudo tee -a /etc/profile.d/java.sh

# Rendre le script ex√©cutable
sudo chmod +x /etc/profile.d/java.sh
source /etc/profile.d/java.sh

# V√©rifier l'installation
java -version
echo "JAVA_HOME: $JAVA_HOME"
```

### **√âtape 1.3: Installation de Docker (M√©thode Officielle)**

```bash
#!/bin/bash
echo "üê≥ INSTALLATION DE DOCKER"

# Ajouter la cl√© GPG officielle Docker
sudo install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo chmod a+r /etc/apt/keyrings/docker.gpg

# Ajouter le repository Docker
echo \
  "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Installer Docker
sudo apt-get update
sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

# D√©marrer et activer Docker
sudo systemctl start docker
sudo systemctl enable docker

# V√©rifier l'installation
sudo docker --version
sudo docker run hello-world
```

### **√âtape 1.4: Installation de Jenkins **

```bash
#!/bin/bash
echo "üéØ INSTALLATION ROBUSTE DE JENKINS"

# 1. Ajouter la cl√© Jenkins
curl -fsSL https://pkg.jenkins.io/debian/jenkins.io-2023.key | sudo tee \
  /usr/share/keyrings/jenkins-keyring.asc > /dev/null

# 2. Ajouter le repository
echo deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] \
  https://pkg.jenkins.io/debian binary/ | sudo tee \
  /etc/apt/sources.list.d/jenkins.list > /dev/null

# 3. Mettre √† jour et installer
sudo apt-get update
sudo apt-get install -y jenkins

# 4. Configurer Jenkins pour Java 17
sudo tee /etc/default/jenkins > /dev/null <<EOF
# Jenkins Configuration - Optimis√©e pour Java 17
JAVA_HOME=$JAVA_HOME
JAVA_ARGS="-Djava.awt.headless=true -Xmx1024m -Xms512m -Djava.net.preferIPv4Stack=true"
JENKINS_HOME="/var/lib/jenkins"
JENKINS_USER="jenkins"
JENKINS_GROUP="jenkins"
JENKINS_WEBROOT="/var/cache/jenkins/war"
JENKINS_LOG="/var/log/jenkins/jenkins.log"
JENKINS_ARGS="--webroot=/var/cache/jenkins/war --httpPort=8080 --httpListenAddress=0.0.0.0"
EOF

# 5. Configurer les permissions Docker pour Jenkins
sudo usermod -a -G docker jenkins

# 6. D√©marrer Jenkins
sudo systemctl daemon-reload
sudo systemctl start jenkins
sudo systemctl enable jenkins

# 7. V√©rifier le statut
sleep 10
echo "üìä Statut Jenkins:"
sudo systemctl status jenkins --no-pager -l

# 8. Afficher le mot de passe initial
echo "üîë Mot de passe initial Jenkins:"
sudo cat /var/lib/jenkins/secrets/initialAdminPassword
```


### **√âtape 1.3: Configuration Initiale Jenkins**

1. **Acc√©der √† Jenkins:** http://localhost:8080
2. **D√©verrouiller avec le mot de passe initial**
3. **Installer les plugins sugg√©r√©s**
4. **Cr√©er un admin user:**
   - Username: `admin`
   - Password: `admin123` (pour le TP)
   - Email: `admin@example.com`

---

## üîå **Partie 2: Installation des Plugins**

### **√âtape 2.1: Plugins via l'Interface Web**

1. **Aller dans:** `G√©rer Jenkins` ‚Üí `G√©rer les Plugins` ‚Üí `Available`
2. **Rechercher et installer:**
   - ‚úÖ **Pipeline**
   - ‚úÖ **Docker Pipeline**
   - ‚úÖ **Git**
   - ‚úÖ **Docker**
   - ‚úÖ **Blue Ocean** (optionnel mais recommand√©)
   - ‚úÖ **Credentials Binding**

### **√âtape 2.2: V√©rification des Plugins**

```bash
# Script de v√©rification
#!/bin/bash
echo "üîç V√©rification des plugins Jenkins..."

# V√©rifier le statut Jenkins
if systemctl is-active --quiet jenkins; then
    echo "‚úÖ Jenkins est en cours d'ex√©cution"
else
    echo "‚ùå Jenkins n'est pas d√©marr√©"
    exit 1
fi

# V√©rifier Docker
if docker --version > /dev/null 2>&1; then
    echo "‚úÖ Docker est install√©: $(docker --version)"
else
    echo "‚ùå Docker n'est pas install√©"
    exit 1
fi

# V√©rifier les permissions Docker pour Jenkins
if groups jenkins | grep -q "docker"; then
    echo "‚úÖ Jenkins fait partie du groupe Docker"
else
    echo "‚ùå Jenkins n'est pas dans le groupe Docker"
    exit 1
fi

echo "üéâ Environnement pr√™t pour le TP!"
```

---

## üì¶ **Partie 3: Cr√©ation du Projet GitHub**

### **√âtape 3.1: Cr√©ation du Repository**

1. **Aller sur:** https://github.com/new
2. **Cr√©er le repository:**
   - Name: `jenkins-docker-pipeline-tp`
   - Description: "TP Jenkins Docker Pipeline"
   - Public
   - ‚úÖ Initialize with README
   - Add .gitignore: Python
   - License: MIT

### **√âtape 3.2: Structure du Projet Locale**

```bash
# Cr√©er la structure de projet
mkdir jenkins-docker-pipeline-tp
cd jenkins-docker-pipeline-tp

# Initialiser Git
git init
git remote add origin https://github.com/votre_username/jenkins-docker-pipeline-tp.git
```

---

## üìÑ **Partie 4: Cr√©ation des Fichiers du Projet**

### **√âtape 4.1: Fichier `app.py`**

```python
from flask import Flask
import os
import datetime

app = Flask(__name__)

@app.route('/')
def hello():
    version = os.getenv('VERSION', '1.0.0')
    build_date = os.getenv('BUILD_DATE', 'Unknown')
    
    return f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>TP Jenkins Docker</title>
        <style>
            body {{ font-family: Arial, sans-serif; margin: 40px; }}
            .container {{ max-width: 800px; margin: 0 auto; }}
            .success {{ color: green; font-weight: bold; }}
            .info {{ background: #f0f0f0; padding: 20px; border-radius: 5px; }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1>üéâ TP Jenkins Docker R√©ussi!</h1>
            <div class="info">
                <p><span class="success">‚úÖ</span> Application d√©ploy√©e avec succ√®s</p>
                <p><strong>Version:</strong> {version}</p>
                <p><strong>Build Date:</strong> {build_date}</p>
                <p><strong>Server Time:</strong> {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            </div>
            <h2>üìä Endpoints disponibles:</h2>
            <ul>
                <li><a href="/health">/health</a> - Health check</li>
                <li><a href="/info">/info</a> - Informations syst√®me</li>
            </ul>
        </div>
    </body>
    </html>
    """

@app.route('/health')
def health():
    return {'status': 'healthy', 'timestamp': datetime.datetime.now().isoformat()}

@app.route('/info')
def info():
    return {
        'version': os.getenv('VERSION', '1.0.0'),
        'build_date': os.getenv('BUILD_DATE', 'Unknown'),
        'environment': os.getenv('ENVIRONMENT', 'development')
    }

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=False)
```

### **√âtape 4.2: Fichier `requirements.txt`**

```txt
Flask==2.3.3
Werkzeug==2.3.7
```

### **√âtape 4.3: Fichier `Dockerfile`**

```dockerfile
# Image de base Python
FROM python:3.9-slim

# M√©tadonn√©es
LABEL maintainer="votre.email@example.com"
LABEL description="TP Jenkins Docker Pipeline"
LABEL version="1.0"

# D√©finir le r√©pertoire de travail
WORKDIR /app

# Copier les requirements et installer les d√©pendances
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copier le code de l'application
COPY app.py .

# Variables d'environnement
ENV VERSION=1.0.0
ENV BUILD_DATE="2024-01-01"
ENV ENVIRONMENT=production
ENV FLASK_APP=app.py
ENV FLASK_ENV=production

# Exposer le port
EXPOSE 5000

# Commande de d√©marrage
CMD ["python", "-m", "flask", "run", "--host=0.0.0.0"]
```

### **√âtape 4.4: Fichier `.dockerignore`**

```gitignore
__pycache__
*.pyc
*.pyo
*.pyd
.Python
env/
pip-log.txt
.DS_Store
.git
.gitignore
README.md
Jenkinsfile
```

### **√âtape 4.5: Fichier `Jenkinsfile`**

```groovy
pipeline {
    agent any
    
    environment {
        // Configuration Docker
        DOCKER_REGISTRY = 'https://index.docker.io/v1/'
        DOCKER_IMAGE_NAME = 'votre_username_docker/jenkins-tp-app'
        DOCKER_CREDENTIALS_ID = 'docker-hub-credentials'
        
        // Variables de version
        APP_VERSION = '1.0.0'
        BUILD_TIMESTAMP = sh(script: 'date +%Y-%m-%d_%H-%M-%S', returnStdout: true).trim()
    }
    
    options {
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '5'))
        disableConcurrentBuilds()
    }
    
    parameters {
        choice(
            name: 'DEPLOY_ENVIRONMENT',
            choices: ['development', 'staging', 'production'],
            description: 'Environnement de d√©ploiement'
        )
        string(
            name: 'IMAGE_TAG',
            defaultValue: 'latest',
            description: 'Tag pour l image Docker'
        )
    }
    
    stages {
        
        // √âtape 1: Pr√©paration
        stage('Pr√©paration') {
            steps {
                echo 'üöÄ D√©but du pipeline Jenkins TP'
                echo "Environnement: ${params.DEPLOY_ENVIRONMENT}"
                echo "Tag: ${params.IMAGE_TAG}"
                echo "Build: ${env.BUILD_ID}"
                
                script {
                    // D√©finir le tag complet
                    env.FULL_IMAGE_TAG = "${env.DOCKER_IMAGE_NAME}:${params.IMAGE_TAG}"
                    env.BUILD_IMAGE_TAG = "${env.DOCKER_IMAGE_NAME}:build-${env.BUILD_ID}"
                }
            }
        }
        
        // √âtape 2: Checkout du code
        stage('Checkout Git') {
            steps {
                echo 'üì• R√©cup√©ration du code source...'
                checkout scm
                
                // Afficher la structure
                sh 'find . -type f -name "*.py" -o -name "*.txt" -o -name "Dockerfile" -o -name "Jenkinsfile" | sort'
            }
        }
        
        // √âtape 3: Tests unitaires
        stage('Tests') {
            steps {
                echo 'üß™ Ex√©cution des tests...'
                
                script {
                    try {
                        // V√©rifier la syntaxe Python
                        sh 'python -m py_compile app.py'
                        echo '‚úÖ Syntaxe Python valide'
                        
                        // V√©rifier les imports
                        sh 'python -c "import flask; print(\"‚úÖ Flask import√© avec succ√®s\")"'
                        
                    } catch (Exception e) {
                        error "‚ùå Erreur dans les tests: ${e.message}"
                    }
                }
            }
        }
        
        // √âtape 4: Build de l'image Docker
        stage('Build Docker Image') {
            steps {
                echo 'üî® Construction de l image Docker...'
                
                script {
                    // Build avec m√©tadonn√©es
                    dockerImage = docker.build(
                        env.BUILD_IMAGE_TAG,
                        "--build-arg VERSION=${env.APP_VERSION} " +
                        "--build-arg BUILD_DATE=${env.BUILD_TIMESTAMP} " +
                        "."
                    )
                }
            }
            
            post {
                success {
                    echo '‚úÖ Build Docker r√©ussi'
                    sh "docker images | grep ${env.DOCKER_IMAGE_NAME}"
                }
                failure {
                    echo '‚ùå Build Docker √©chou√©'
                }
            }
        }
        
        // √âtape 5: Scan de s√©curit√© (basique)
        stage('Scan S√©curit√©') {
            steps {
                echo 'üîí Scan de s√©curit√© basique...'
                
                script {
                    // V√©rifier les vuln√©rabilit√©s connues
                    sh """
                    echo "üìã Analyse de l'image..."
                    docker run --rm ${env.BUILD_IMAGE_TAG} pip list
                    echo "‚úÖ Scan basique termin√©"
                    """
                }
            }
        }
        
        // √âtape 6: Push vers Docker Hub
        stage('Push to Docker Hub') {
            steps {
                echo 'üì¶ Envoi vers Docker Hub...'
                
                script {
                    // Se connecter √† Docker Hub
                    docker.withRegistry(env.DOCKER_REGISTRY, env.DOCKER_CREDENTIALS_ID) {
                        // Push avec le tag sp√©cifi√©
                        dockerImage.push("${params.IMAGE_TAG}")
                        
                        // Tag suppl√©mentaire avec l'ID de build
                        dockerImage.push("build-${env.BUILD_ID}")
                        
                        echo "‚úÖ Image pouss√©e: ${env.FULL_IMAGE_TAG}"
                    }
                }
            }
        }
        
        // √âtape 7: D√©ploiement
        stage('D√©ploiement') {
            steps {
                echo 'üöÄ D√©ploiement de l application...'
                
                script {
                    // Arr√™ter le conteneur existant
                    sh 'docker stop tp-app || true'
                    sh 'docker rm tp-app || true'
                    
                    // Lancer le nouveau conteneur
                    sh """
                    docker run -d \
                        --name tp-app \
                        -p 5000:5000 \
                        -e ENVIRONMENT=${params.DEPLOY_ENVIRONMENT} \
                        -e VERSION=${env.APP_VERSION} \
                        -e BUILD_DATE=${env.BUILD_TIMESTAMP} \
                        ${env.FULL_IMAGE_TAG}
                    """
                    
                    echo "üéâ Application d√©ploy√©e sur http://localhost:5000"
                }
            }
        }
        
        // √âtape 8: Tests de d√©ploiement
        stage('Tests de D√©ploiement') {
            steps {
                echo 'üîç V√©rification du d√©ploiement...'
                
                script {
                    // Attendre que l'application soit pr√™te
                    sleep 10
                    
                    // Tester l'endpoint principal
                    sh 'curl -f http://localhost:5000/ || exit 1'
                    echo '‚úÖ Endpoint / accessible'
                    
                    // Tester l'health check
                    sh 'curl -f http://localhost:5000/health || exit 1'
                    echo '‚úÖ Health check OK'
                    
                    // Afficher les logs du conteneur
                    sh 'docker logs tp-app --tail 10'
                }
            }
        }
    }
    
    post {
        always {
            echo 'üìä Pipeline termin√© - Nettoyage...'
            
            // Nettoyage des conteneurs arr√™t√©s
            sh 'docker ps -aq --filter status=exited | xargs -r docker rm || true'
            
            // Nettoyer les images interm√©diaires
            sh 'docker image prune -f'
            
            // Sauvegarder l'espace de travail (optionnel)
            archiveArtifacts artifacts: '**/*.py, **/*.txt, **/Dockerfile', fingerprint: true
        }
        
        success {
            echo 'üéâ TP R√âUSSI! Pipeline ex√©cut√© avec succ√®s'
            
            // Afficher les informations de d√©ploiement
            sh """
            echo "=== INFORMATIONS DE D√âPLOIEMENT ==="
            echo "Application: http://localhost:5000"
            echo "Health Check: http://localhost:5000/health"
            echo "Image Docker: ${env.FULL_IMAGE_TAG}"
            echo "Environnement: ${params.DEPLOY_ENVIRONMENT}"
            echo "Build ID: ${env.BUILD_ID}"
            """
        }
        
        failure {
            echo '‚ùå Pipeline √©chou√© - V√©rifier les logs'
            
            // Sauvegarder les logs en cas d'√©chec
            sh 'docker logs tp-app > deployment_failure.log 2>&1 || true'
            archiveArtifacts artifacts: 'deployment_failure.log', fingerprint: true
        }
        
        changed {
            echo 'üìà Statut du pipeline modifi√© depuis la derni√®re ex√©cution'
        }
    }
}
```

### **√âtape 4.6: Fichier `README.md`**

```markdown
# TP Jenkins Docker Pipeline

## üìã Description
Ce projet d√©montre la cr√©ation d'un pipeline Jenkins complet pour build et d√©ployer une application Flask sur Docker Hub.

## üèóÔ∏è Architecture
- **Application:** Flask Python
- **CI/CD:** Jenkins Pipeline
- **Container:** Docker
- **Registry:** Docker Hub

## üöÄ Utilisation

### Acc√®s √† l'application
```bash
# Apr√®s d√©ploiement
curl http://localhost:5000
```

### Endpoints
- `GET /` - Page principale
- `GET /health` - Health check
- `GET /info` - Informations syst√®me

## üîß Configuration
Voir le Jenkinsfile pour la configuration compl√®te du pipeline.
```

---

## üîê **Partie 5: Configuration des Credentials Jenkins**

### **√âtape 5.1: Cr√©ation du Token Docker Hub**

1. **Aller sur:** https://hub.docker.com/settings/security
2. **Cr√©er un nouveau token:**
   - Name: `jenkins-tp-token`
   - Permissions: **Read, Write, Delete**
3. **Copier le token** (‚ö†Ô∏è ne s'affiche qu'une fois!)

### **√âtape 5.2: Ajout dans Jenkins**

1. **Jenkins** ‚Üí **G√©rer Jenkins** ‚Üí **Manage Credentials**
2. **Global** ‚Üí **Add Credentials**
3. **Remplir:**
   - Kind: `Username with password`
   - Scope: `Global`
   - Username: `votre_username_docker`
   - Password: `votre_token_docker_hub`
   - ID: `docker-hub-credentials`
   - Description: `Credentials Docker Hub pour TP`

---

## üõ†Ô∏è **Partie 6: Cr√©ation du Pipeline Jenkins**

### **√âtape 6.1: Configuration du Job**

1. **Jenkins** ‚Üí **Nouveau Item**
2. **Nom:** `tp-jenkins-docker-pipeline`
3. **Type:** `Pipeline`
4. **Configuration:**
   - Definition: `Pipeline script from SCM`
   - SCM: `Git`
   - Repository URL: `https://github.com/votre_username/jenkins-docker-pipeline-tp.git`
   - Branches: `*/main`
   - Script Path: `Jenkinsfile`

### **√âtape 6.2: Premier Build**

1. **Cliquer sur `Build Now`**
2. **Observer la progression dans Blue Ocean:**
   ```bash
   # Acc√©der √† Blue Ocean
   http://localhost:8080/blue
   ```
3. **V√©rifier chaque √©tape**

---

## üß™ **Partie 7: Tests et Validation**

### **√âtape 7.1: Tests Manuel**

```bash
# V√©rifier l'application d√©ploy√©e
curl http://localhost:5000

# V√©rifier l'health check
curl http://localhost:5000/health

# V√©rifier les informations
curl http://localhost:5000/info

# V√©rifier l'image sur Docker Hub
docker pull votre_username_docker/jenkins-tp-app:latest
docker images | grep jenkins-tp-app
```

### **√âtape 7.2: V√©rification des Logs**

```bash
# V√©rifier les logs Jenkins
tail -f /var/log/jenkins/jenkins.log

# V√©rifier les logs du conteneur
docker logs tp-app -f

# V√©rifier les images Docker
docker ps
docker images
```

---

## üìä **Partie 8: Validation du TP**

### **Checklist de Validation**

- [ ] **‚úÖ Jenkins accessible** sur http://localhost:8080
- [ ] **‚úÖ Docker install√©** et fonctionnel
- [ ] **‚úÖ Plugins Jenkins** install√©s
- [ ] **‚úÖ Repository GitHub** cr√©√© avec le code
- [ ] **‚úÖ Credentials Docker Hub** configur√©s
- [ ] **‚úÖ Pipeline Jenkins** cr√©√© et configur√©
- [ ] **‚úÖ Build r√©ussi** sans erreurs
- [ ] **‚úÖ Image Docker** build√©e et pouss√©e
- [ ] **‚úÖ Application d√©ploy√©e** et accessible
- [ ] **‚úÖ Tests automatiques** pass√©s
- [ ] **‚úÖ Logs propres** sans warnings critiques

### **Commandes de Validation Finale**

```bash
#!/bin/bash
echo "üéØ VALIDATION FINALE DU TP"

# 1. V√©rifier Jenkins
echo "1. V√©rification Jenkins..."
sudo systemctl status jenkins --no-pager -l

# 2. V√©rifier Docker
echo "2. V√©rification Docker..."
docker --version
docker ps

# 3. V√©rifier l'application
echo "3. V√©rification Application..."
curl -s http://localhost:5000/health | grep -q "healthy" && echo "‚úÖ Application healthy" || echo "‚ùå Application down"

# 4. V√©rifier l'image Docker
echo "4. V√©rification Image Docker..."
docker images | grep -q "jenkins-tp-app" && echo "‚úÖ Image pr√©sente" || echo "‚ùå Image manquante"

# 5. V√©rifier les credentials
echo "5. V√©rification Credentials..."
echo "‚úÖ Configuration termin√©e"

echo "üéâ TP JENKINS DOCKER R√âUSSI!"
```

---

## üéì **Conclusion**

**F√©licitations!** Vous avez r√©ussi √†:

- ‚úÖ **Configurer un environnement Jenkins complet**
- ‚úÖ **Cr√©er un pipeline CI/CD sophistiqu√©**
- ‚úÖ **Automatiser le build d'images Docker**
- ‚úÖ **D√©ployer sur Docker Hub**
- ‚úÖ **D√©ployer une application Flask**
- ‚úÖ **Mettre en place des tests automatiques**

**Prochaines √©tapes possibles:**
- Ajouter des tests unitaires Python
- Int√©grer un scan de s√©curit√© (Trivy, Snyk)
- D√©ployer sur Kubernetes
- Ajouter des notifications (Slack, Email)
- Mettre en place un d√©ploiement blue-green

---

**üìö R√©f√©rences:**
- [Documentation Jenkins](https://www.jenkins.io/doc/)
- [Documentation Docker](https://docs.docker.com/)
- [Documentation Flask](https://flask.palletsprojects.com/)

**üêõ D√©pannage:** Consultez les logs Jenkins et Docker en cas d'erreur!
